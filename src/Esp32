#include <FirebaseESP32.h>
#include <LiquidCrystal_I2C.h>
#include <EEPROM.h>
#include <WiFi.h>
#include <RTClib.h>

#define WIFI_USERNAME           "100.000USDorLoser"
#define WIFI_PASSWORD           "huylong1999"
#define FIREBASE_HOST           "https://esp32-12371-default-rtdb.firebaseio.com/"
#define FIREBASE_AUTH           "Nv6h0vZhJ3inDzJLvnHieGssXKyxnMIbBARuURfp"


#define FIREBASE_SENSOR_PATH    "/path_2/sensor"
#define FIREBASE_CONTROL_PATH   "/path_1/control"
#define FIREBASE_STATUS_PATH    "/path_3/device_status"


#define LCD_I2C_ADDRESS 0x27
#define LCD_ROWS        4                                               // LCD size
#define LCD_COLUMNS     20

/* store relay state (in case hard reset) */
#define EEPROM_SIZE     1
#define EEPROM_ADDRESS  0x00

/* RELAY PIN */
#define DEVICE_1 16
#define DEVICE_2 17
#define DEVICE_3 18
#define DEVICE_4 19

/* Sensor pin */
#define DHT11_PIN 34
#define BRIGHT_PIN 35
#define MOISTURE 36

void init_pin_mode();
bool wait_for(unsigned long interval);

/* lcd subfuntion */
void lcd_setup();
void lcd_update_realtime();
void lcd_update_relay_status(uint8_t relay_byte);
void lcd_update_sensor_data(float *sensor_array);

/* analyse and control relay subfunction */
bool analyse_control_data(uint8_t control_byte, uint8_t *state_byte);
void control_relay(uint8_t control_byte);

/* sensor subfunction */
float get_bright_data();
float get_moisture_data();

/* wifi subfunction */
void connect_eps32_wifi();

/* firebase subfunction */
void connect_esp32_firebase();

/* Define Firebase  ESP32 data object */
FirebaseData fbdo;
/* Lcd initialize */
LiquidCrystal_I2C lcd(LCD_I2C_ADDRESS, LCD_COLUMNS, LCD_ROWS);
/* initialize realtime module */
RTC_DS1307 rtc;
/* initalize dht11 */
DHT dht(DHT11_PIN, DHT11);

byte WATER_SYMBOL[] = {0x00, 0x04, 0x0E, 0x1F, 0x1F, 0x1F, 0x1F, 0x0E};
byte DEGGREE_SYMBOL[] = {0x18, 0x18, 0x06, 0x09, 0x08, 0x08, 0x09, 0x06};
byte TEMPERATURE_SYMBOL[] = { 0x03, 0x0B, 0x08, 0x1E, 0x08, 0x08, 0x0A, 0x04};
byte ON_SYMBOL[] = { 0x1F, 0x1F, 0x1F, 0x1F, 0x11, 0x11, 0x11, 0x1F};
byte OFF_SYMBOL[] = { 0x1F, 0x11, 0x11, 0x11, 0x1F, 0x1F, 0x1F, 0x1F};

uint8_t relay_state = 0;

void setup(){

    delay(1000);
    init_pin_mode();
    lcd_setup();
    connect_eps32_wifi();
    connect_esp32_firebase();
    EEPROM.begin(EEPROM_SIZE);
    relay_state = (EEPROM.read(EEPROM_ADDRESS)) & 0x0F;
}

void loop(){

    yield();
    if(wait_for(755)){

        if(FIREBASE.getString(fbdo, FIREBASE_CONTROL_PATH)){

            String control_data = fbdo.stringData();
            if(analyse_control_data(control_data.toInt(), &relay_state)){


                control_relay(relay_state);
                lcd_update_relay_status();
                EEPROM.write(EEPROM_ADDRESS, relay_state);
                EEPROM.commit();
            }
        }
        else{

            //Serial.println(fbdo.errorReason);
            return;
        }
    }
    else if(wait_for(3555)){

        float sensor_data[4];
        sensor_data[0] = dht.readTemperature();
        sensor_data[1] = dht.readHumidity();
        sensor_data[2] = get_bright_data();
        sensor_data[3] = get_moisture_data();
        lcd_update_sensor_data(sensor_data);
        String string_send = "";

        string_send += dht.readTemperature();
        string_send += "*";
        string_send += dht.readHumidity();
        string_send += "*";
        string_send += analogRead
    }
}

void connect_eps32_wifi(){

    WiFi.begin(WIFI_USERNAME, WIFI_PASSWORD);
    while (WiFi.status() != WL_CONNECTED){

        delay(200);
    }
}

void connect_esp32_firebase(){

    Firebase.begin(FIREBASE_HOST, FIREBASE_AUTH);
    Firebase.reconnectWiFi(true);                                       // enable auto reconnect the WiFi when connection lost
}

void init_pin_mode(){

    pinMode(DEVICE_1, OUTPUT);
    pinMode(DEVICE_2, OUTPUT);
    pinMode(DEVICE_3, OUTPUT);
    pinMode(DEVICE_4, OUTPUT);
    pinMode(DHT11_PIN, INPUT);
    pinMode(BRIGHT_PIN, OUTPUT);
    pinMode(MOISTURE_PIN, OUTPUT);
}

bool analyse_control_data(uint8_t control_byte, uint8_t *pState_byte, uint8_t state_byte){

    /* control_byte format in decimal: <relay that has change><state you want to change>
        example: 41 mean user want to turn on fourth relay */
    uint8_t tenths = control_byte / 10;
    uint8_t units = control_byte % 10;
    if(tenths > 4 || tenths < 1 || (units != 0 && units != 1)){

        return false;                                                   // format data is not familiar
    }
    else if{

        if(units == 1){

            state_byte |= (0x01 << (tenths - 1));                      // set relay bit to 1
        }
        else if(units == 0){

            state_byte &= ~(0x01 << (tenths - 1));                     // clear relay bit
        }

    }

}

bool wait_for(unsigned long interval){                                  // wait for a time (you can do other work)

    static bool is_enabled_timing = false;
    /* in fact, millis function run over and over, so we need to keep this static to mark your start time */
    static unsigned long previous_millis = 0;
    unsigned long current_millis = millis();
    if(!is_enabled_timing){                                             // check if timer was start to timing before?

        is_enabled_timing = true;
        previous_millis = current_millis;                               // if yes, set previous millis and start couting
    }
    if(current_millis - previous_millis >= interval)                    // check if timing reached limit
    {

        is_enabled_timing = false;                                      // stop using timer
        return true;
    }
    return false;
}
/**********sensor sub fuction**************************************************/
float get_bright_data(){

    return (analogRead(BRIGHT_PIN) / 4096) * 100;
}

float get_moisture_data(){

    return (analogRead(MOISTURE_PIN) / 4096) * 100;
}

/**********LCD SUB FUNCTION ****************************************************/
void lcd_setup(){

    lcd.init();                                                         // setup lcd
    lcd.backlight();
    lcd.createChar(0, WATER_SYMBOL);                                    // create char
    lcd.createChar(1, DEGGREE_SYMBOL);
    lcd.createChar(2,TEMPERATURE_SYMBOL);
    lcd.createChar(3, ON_SYMBOL);
    lcd.createChar(4, OFF_SYMBOL);
    /* print header */
    lcd.setCursor(0, 0);
    lcd.print("R1:  R2:  R3:  R4:");
    lcd.setCursor(0, 1);    lcd.write(2);       lcd.setCursor(8, 1);   lcd.write(3);
    lcd.setCursor(10, 1);    lcd.write(1);      lcd.setCursor(18, 1);   lcd.print("%");
    lcd.setCursor(0, 2);    lcd.print("Bri: "); lcd.setCursor(8, 2); lcd.print("%");
    lcd.setCursor(10, 2);    lcd.print("Moil:"); lcd.setCursor(18, 2); lcd.print("%");
}

void lcd_update_realtime(){

    DateTime now = rtc.now();
    uint16_t timer_buff[6];
    char time_str[20];
    timer_buff[0] = now.hour();
    timer_buff[1] = now.minute();
    timer_buff[2] = now.second();
    timer_buff[3] = now.day();
    timer_buff[4] = now.month();
    timer_buff[5] = now.year();
    lcd.setCursor(7, 3);
    sprintf(time_str, "%d:%d:%d %d/%d/20%d", timer_buff[0], timer_buff[1],
            timer_buff[2], timer_buff[3], timer_buff[4], timer_buff[5])
    lcd.print(print_str);
}

void lcd_update_sensor_data(float *sensor_array){

    lcd.setCursor(2, 1);
    lcd.print(*sensor_array);
    lcd.setCursor(12, 1);
    lcd.print(*(sensor_array + 1));
    lcd.setCursor(2, 2);
    lcd.print(*(sensor_array + 2));
    lcd.setCursor(12, 2);
    lcd.print(*(sensor_array + 3));
}

void lcd_update_relay_status(uint8_t relay_byte){

    lcd.setCursor(3, 0);                                                // RELAY 1 state
    if((relay_byte & 0x01) != 0x00){                                    // first LSB of relay_state byte
        lcd.write(3);
    }
    else{
        lcd.write(4);
    }

    lcd.setCursor(8, 0);                                                // RELAY 2 state
    if((relay_byte & 0x02) != 0x00){                                    // second LSB of relay_state byte
        lcd.write(3);
    }
    else{
        lcd.write(4);
    }

    lcd.setCursor(13, 0);                                                // RELAY 3 state
    if((relay_byte & 0x04) != 0x00){                                    // third LSB of relay_state byte
        lcd.write(3);
    }
    else{
        lcd.write(4);
    }

    lcd.setCursor(18, 0);                                                // RELAY 4 state
    if((relay_byte & 0x08) != 0x00){                                    // fourth bit of relay_state byte
        lcd.write(3);
    }
    else{
        lcd.write(4);
    }
}
